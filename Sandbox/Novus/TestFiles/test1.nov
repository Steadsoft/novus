// First line
'test'

/* symbolic functions * H */

// line comments

i_am_an_ident
1234567
      "i start at column 7"

{ and33_so_ami }

/* int below */

1234567890

&(x) = get address of x
*(p) = deref pointer p
**   = exponentiation

F(G<A,B>(7));

F(G(A,B)(7));

F(G{A,B}(7));

F(G<A^B^C>(7));



/*

This could be how we handle pointers */

var ptr = addr[data];
var data = cont[ptr];

// OR 

var ptr  = address[data];
var data = content[data];


arion = b ** ()

a = *(p);

result = some_builtin[arglist]
result = some_builtin{arglist}
result = some_builtin(arglist);



/* 
   Novus could use [ ] for representing an arglist in a builtin
   function call. The other ( ) is absolutely fine for user 
   methods, functions and array accessors. */

/* 
   Novus can rest upon the idea of a language namespace and that can be
   written with a leading @ that is not available to users in names. */

/*

result = sizeof[arg];
result = nameof[arg];

and so on, are actually calls into functions defined in a namespace
named: @language.builtin { }

*/


X++
X--
x!
new
typeof
checked
unchecked
default
nameof
sizeof
stackalloc

text = "this is just a load of charcaters"

this = 'this is too but is delimited with a different char'


*(p)
&(p)

tokens
->
+
-
++
--
*
**
=
==
>
>>
>>=
<
<<
<<=


