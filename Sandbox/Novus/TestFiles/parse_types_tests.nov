namespace a.x.rere
{

   type ee enum public static
   {
        A,
        B,
        C,
   }


   type IAmAnInterface<T,B> interface
   {
        def Reboot (a int) (int);
        def Reboot (b int) (int);
   }

   // |||this is some text inside which we can embed " or "" or ' or ' or whatever was want|||;

   type aa 
   {
      public private
      {

      }

      internal
      {
   
      }

      public 
      {
   
      }

      internal protected
      {
   
      }

      private protected
      {
            
      }

   }

   type abcdefg
   {
   
   }

   namespace b
   {
      namespace namespace
      {
         // The parser does not care about these words or dupes etc, that's handled by a second
         // pass after the parse is done.

         type Category<Z, U<X>, V<Z>> class sealed sealed abstract static public private
         {
         
         }

         type Category<T, U<X>, V<Z,X>> class sealed sealed abstract static public private
         {
            type Window class public struct abstract sealed 
            {
               
               // This is a method defintion, it has no return type, so its not a 'function'

               def ClearScreen (arg1 int, arg2 string, arg3 float) private protected internal public
               {
                  return;
               }

               // This is a function delaration, returns a string

               def GetScreenArea (arg1 float ref, arg2 int out)  (string) public override
               {
                  return;
               }

               // this is an overload not a dupe declaration

               def GetScreenArea (arg1 string)  (string) public override public
               {
                  return;
               }

               def GetScreenArea (argx string)  (string) public override public
               {
                  return "so long";
               }

               def Name string public readonly public; // a field definition
               def Name double private readonly public; // a field definition

                type GetScreenArea<A,B<X,Y>,C,D> class
                {
                   // We can't really begin to work on actual statements yet because we must
                   // deal with parsing expressions and we can't do that much until we have
                   // a more solid set of ideas for operators and so on.

                   /* but lets play a little..

                   call some_method; // no args, so no parens, optional parens ?

                   call some_other_method (<expression>,<expression>...);

                   result = some_function; // no args, so no parens, optional parens ?

                   result = some_other_function (<expression>,<expression>...)

                   goto label;

                   while (<expression>)
                      <statement>

                   until (<expression>)
                      <statement>

                   select (<expression>)
                      <statmenet>

                   break [<label>]

                   */
                }
            }

            type Window struct
            {

            }
         }
      }
   } 

   namespace b
   {
   
   }
}

/*

Consider a syntax like this:

type Data struct
{
   public 
   {
   
   }

   internal
   {
   
   }
}

*/


namespace d
{
   type Umbrealla class
   {

   }
}

namespace abc;

// using Steadsoft.Novus.Support;

namespace Steadsoft.Novus.Support
{
   namespace Steadsoft.Novus.Compiler
   {

   }
}

type Umbrealla class
{

}

type Window class public abstract sealed
{

}

type Category1 class sealed sealed abstract static
{
    type Category2 class sealed sealed abstract static
    {
        type Category3 class sealed sealed abstract static
        {
            type Category4 class sealed sealed abstract static
            {

            }
        }
    }
}

/*

arrays do not need to use [ and ]. These are reserved for the language's builtin functions.

here is an array:

type class Window
{

   def table(7) string; array 0 - 6 of string

   def table(9,9,9) double; 3D array 0 - 9 = 1,000 elements.

   def table(*) int; array of int's no compile time dimension.

   def names(*,*) string;  2D array of strings no compile time dimensions.
}

Loops:

   for I = 0 to 100 by 9
   {
   
   }

   for I = 100 to 0 by -1
   {
   
   }

   while a > b
   {
   
   }

   while (a > b)
   {
   
   }

   until x = y
   {
   
   }

*/