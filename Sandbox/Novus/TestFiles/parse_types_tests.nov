namespace a.x.rere
{
   type ee enum public
   {
        A,
        B,
        C,
        A
   }

   type aa 
   {
      public private
      {
   
      }

      internal
      {
   
      }

      public 
      {
   
      }

      internal protected
      {
   
      }

      private protected
      {
            
      }

   }

   type aa
   {
   
   }

   namespace b
   {
      namespace namespace
      {
         // The parser does not care about these words or dupes etc, that's handled by a second
         // pass after the parse is done.

         type Category class sealed sealed abstract static public private
         {
            type Window class public struct abstract sealed 
            {
               
               // This is a method defintion, it has no return type, so its not a 'function'

               def ClearScreen (arg1 int, arg2 string, arg3 float) private protected internal public
               {
                  return;
               }

               // This is a function delaration, returns a string

               def GetScreenArea (arg1 float ref, arg2 int out)  (string) public override
               {
                  return;
               }

               def GetScreenArea (arg1 string)  (string) public override public
               {
                  return;
               }

               def Name string public readonly public; // a field definition
               def Name double private readonly public; // a field definition

                type GetScreenArea class
                {
                   // We can't really begin to work on actual statements yet because we must
                   // deal with parsing expressions and we can't do that much until we have
                   // a more solid set of ideas for operators and so on.

                   /* but lets play a little..

                   call some_method; // no args, so no parens

                   call some_other_method (<expression>,<expression>...);

                   goto label;

                   while (<expression>)
                      <statement>

                   until (<expression>)
                      <statement>


                   */
                }
            }

            type Window
            {

            }
         }
      }
   } 

   namespace b
   {
   
   }
}

/*

Consider a syntax like this:

type Data struct
{
   public 
   {
   
   }

   internal
   {
   
   }
}

*/


namespace d
{
   type Umbrealla class
   {

   }
}

namespace abc;

// using Steadsoft.Novus.Support;

namespace Steadsoft.Novus.Support
{
   namespace Steadsoft.Novus.Compiler
   {

   }
}

type Umbrealla class
{

}

type Window class public abstract sealed
{

}

type Category1 class sealed sealed abstract static
{
    type Category2 class sealed sealed abstract static
    {
        type Category3 class sealed sealed abstract static
        {
            type Category4 class sealed sealed abstract static
            {

            }
        }
    }
}